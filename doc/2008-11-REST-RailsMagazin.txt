In den letzten ein bis zwei Jahren setzt sich REST, bzw. genauer: RESTful HTTP, als Alternative zu SOAP- und WSDL-basierten Web-Services immer mehr durch – zumindest, was die Open Source- und Web 2.0-Gemeinde angeht. Wie es sich gehört, ist Rails hier ganz vorn mit dabei: die ursprünglich im Framework enthaltene Unterstützung für SOAP ist seit Version 2.0 kein Kernbestandteil mehr und muss bei Bedarf als Plugin nachinstalliert werden. Wie immer "opinionated" hat sich das Rails-Team dafür entschieden, REST als Standardweg sowohl für die Architektur der Web-UIs als auch für die Maschinen-zu-Maschinen-Kommunikation einzusetzen.

Hinter REST (REpresentational State Transfer) verbirgt sich die Architektur des WWW, definiert von Mit-Erfinder Roy T. Fielding. Ganz kurz zusammengefasst lässt sie sich auf einige Grundprinzipien reduzieren. Das zentrale Element in einer REST-Architektur sind _Ressourcen_, die klar identifiziert werden können. In der konkreten Ausprägung HTTP sind für diese Identifikation URIs zuständig. Ressourcen werden niemals direkt angesprochen, sondern nur über _Repräsentationen_, die den Status enthalten und zwischen Client und Server transferiert werden. Alle Ressourcen unterstützen die gleiche Schnittstelle, bei HTTP vor allem bestehend aus den Standard-Methoden GET, PUT, POST und DELETE. Schließlich heißt das WWW nicht umsonst World Wide _Web_: Ressourcen sind miteinander vernetzt. Das spiegelt sich über Links in den Repräsentationen wider, die den Fluss des Clients und damit der Gesamtanwendung gesteuert werden können.

Von den Mainstream-Web-Frameworks in populären Sprachen ist Rails eines der wenigen, das den REST-Ansatz gut unterstützt: Seit Rails 1.2 gibt es optional, seit 2.0 als Default nur noch ein Scaffolding, das weitgehend RESTful ist: eine mit `map.resources  addresses` in der `config/routes.rb` bekanntgemachte Standard-Ressource wird auf sinnvolle URIs abgebildet und die Methoden korrekt interpretiert (siehe Tabelle 1). Das ist schon ein guter Startpunkt, aber auch nicht mehr: damit sich eine Anwendung berechtigt mit dem Prädikat "RESTful" schmücken kann, ist Nacharbeit notwendig. Glücklicherweise lässt sich das – Rails-typisch – mit relativ wenig Code erledigen. In den folgenden Abschnitten möchte ich zeigen, wie wir einen RESTful Web-Service auf Rails-Basis entwickeln können. Dabei lege ich den Fokus auf die Server-Seite (oder "Provider"-Seite für die SOA-Fans); in einem Folgeartikel werden wir uns mit der Client-Seite (dem "Consumer") beschäftigen.

Für unser Experiment legen wir zwei einfache Modelle an: Kunde mit Name, Ort und Land sowie Kundenkontakt (ein Ansprechpartner beim Kunden) mit Vor- und Nachname und einer 1:n-Beziehung dazwischen (Listing 1). In config/routes.rb definieren wir die Ansprechpartner als Unterressourcen der Kunden. Da wir nur ein Modell angelegt haben und uns der Controller fehlt, gehen unsere Aktionen im Moment ins Leere. Wir verzichten bewusst auf das Scaffolding und erstellen unseren ersten Controller explizit mit script/generate controller Customers. Natürlich kann man auch mit dem Scaffolding beginnen und dieses entsprechen modifizieren und die generierten Methoden modifizieren – ich möchte aber an dieser Stelle explizit einen reinen Web-Service, d.h. ohne Benutzeroberfläche gestalten.

Als erstes definieren wir im generierten CustomersController eine index-Aktion (Listing 2). Diese unterscheidet sich in zwei wesentlichen Punkten von dem generierten Scaffolding: Pagination und XML-Rendering. 

Der Pagination-Mechanismus sorgt dafür, dass nicht alle, sondern nur eine begrenzte Menge von Daten zurückgegeben werden. Das ist sinnvoll, wenn die Datenmenge potenziell sehr groß werden kann (also praktisch immer). In einer Web-Oberfläche sind wir es gewohnt, Suchergebnisse seitenweise präsentiert zu bekommen. Das ist in einem Web-Service nicht anders: auch hier möchte man sich gegen einen – absichtlichen oder versehentlichen – Zugriff auf sämtliche Kundendaten absichern. In einem Web-Service im REST-Stil benutzen wir dazu das gleiche Verfahren, in diesem Fall umgesetzt durch das will_paginate-Plugin [2]. 

Unter anderem deswegen müssen wir auch die XML-Darstellung anpassen: Das Standard-Scaffolding wandelt die Liste hierzu einfach generisch in XML um. Für die Verwendung aus dem Standard-Rails-Client ActiveResource ist das in Ordnung. Das dabei generierte XML genügt aber nur sehr spartanischen Ansprüchen. Stattdessen sorgen wir mit der leeren format.xml-Anweisung dafür, dass das Framework nach einer passenden View sucht. Diese realisieren wir mit dem XML-Builder, d.h. in einer Datei mit dem Namen index.xml.builder (siehe Listing 3).

Die XML-Builder-Syntax macht es recht einfach, zu erkennen, wie eine Antwort aussieht: Noch bevor die eigentlichen Inhalte dargestellt werden, werden die notwnendigen Links für das Vor- und Zurückblättern im Resultat generiert. Dazu ist muss man eine eigene Renderer-Klasse erstellen und dem will_paginate-Plugin übergeben – die Details dazu würden hier zu weit führen, sie können den vollständigen Code aber unter ... herunterladen. 